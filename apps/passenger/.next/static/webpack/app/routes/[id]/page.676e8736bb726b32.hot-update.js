"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/routes/[id]/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllRoutes: () => (/* binding */ getAllRoutes),\n/* harmony export */   getPopularRoutes: () => (/* binding */ getPopularRoutes),\n/* harmony export */   getRouteById: () => (/* binding */ getRouteById),\n/* harmony export */   getSchedulesByRoute: () => (/* binding */ getSchedulesByRoute),\n/* harmony export */   searchLocationSuggestions: () => (/* binding */ searchLocationSuggestions),\n/* harmony export */   searchRoutes: () => (/* binding */ searchRoutes),\n/* harmony export */   submitFeedback: () => (/* binding */ submitFeedback)\n/* harmony export */ });\n// Direct API calls to passenger app's own routes\nconst API_BASE = '/api';\nasync function searchRoutes(from, to) {\n    try {\n        const response = await fetch(\"\".concat(API_BASE, \"/routes\"));\n        if (!response.ok) throw new Error('Failed to fetch');\n        let routes = await response.json();\n        // Filter by locations if provided\n        if (from || to) {\n            routes = routes.filter((route)=>{\n                const matchesFrom = !from || route.startLocation.toLowerCase().includes(from.toLowerCase()) || route.stops.some((stop)=>stop.stopName.toLowerCase().includes(from.toLowerCase()));\n                const matchesTo = !to || route.endLocation.toLowerCase().includes(to.toLowerCase()) || route.stops.some((stop)=>stop.stopName.toLowerCase().includes(to.toLowerCase()));\n                return matchesFrom && matchesTo;\n            });\n        }\n        return routes.map((route)=>({\n                route,\n                nextDepartures: [\n                    {\n                        departureTime: '06:00',\n                        busId: 1\n                    },\n                    {\n                        departureTime: '06:30',\n                        busId: 1\n                    },\n                    {\n                        departureTime: '07:00',\n                        busId: 1\n                    }\n                ],\n                estimatedArrival: calculateArrivalTime(route.estimatedDuration),\n                currentBuses: []\n            }));\n    } catch (error) {\n        console.error('Error searching routes:', error);\n        throw new Error('Failed to search routes. Please check your connection.');\n    }\n}\nasync function getPopularRoutes() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE, \"/routes\"));\n        if (!response.ok) throw new Error('Failed to fetch');\n        const routes = await response.json();\n        return routes.slice(0, 6);\n    } catch (error) {\n        console.error('Error fetching popular routes:', error);\n        throw new Error('Failed to load popular routes. Please check your connection.');\n    }\n}\nasync function getRouteById(id) {\n    try {\n        const response = await fetch(\"\".concat(API_BASE, \"/routes\"));\n        if (!response.ok) throw new Error('Failed to fetch');\n        const routes = await response.json();\n        return routes.find((route)=>route.id === id) || null;\n    } catch (error) {\n        console.error('Error fetching route:', error);\n        return null;\n    }\n}\nasync function getSchedulesByRoute(routeId) {\n    try {\n        // Mock schedules for now since we don't have schedule API yet\n        return [\n            {\n                id: '1',\n                departureTime: '06:00',\n                arrivalTime: '06:35',\n                status: 'SCHEDULED'\n            },\n            {\n                id: '2',\n                departureTime: '06:30',\n                arrivalTime: '07:05',\n                status: 'SCHEDULED'\n            },\n            {\n                id: '3',\n                departureTime: '07:00',\n                arrivalTime: '07:35',\n                status: 'IN_PROGRESS'\n            }\n        ];\n    } catch (error) {\n        console.error('Error fetching schedules:', error);\n        return [];\n    }\n}\nasync function submitFeedback(feedback) {\n    try {\n        const response = await fetch(\"\".concat(API_BASE, \"/feedback\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(feedback)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error('Error submitting feedback:', error);\n        throw new Error('Failed to submit feedback. Please try again.');\n    }\n}\nasync function searchLocationSuggestions(query) {\n    try {\n        const routes = await getAllRoutes();\n        const locations = [];\n        routes.forEach((route)=>{\n            var _route_stops;\n            if (route.startLocation.toLowerCase().includes(query.toLowerCase())) {\n                locations.push({\n                    id: \"route_start_\".concat(route.id),\n                    name: route.startLocation,\n                    coordinates: [\n                        38.7636,\n                        9.0054\n                    ],\n                    type: 'bus_station'\n                });\n            }\n            if (route.endLocation.toLowerCase().includes(query.toLowerCase())) {\n                locations.push({\n                    id: \"route_end_\".concat(route.id),\n                    name: route.endLocation,\n                    coordinates: [\n                        38.7636,\n                        9.0054\n                    ],\n                    type: 'bus_station'\n                });\n            }\n            (_route_stops = route.stops) === null || _route_stops === void 0 ? void 0 : _route_stops.forEach((stop)=>{\n                if (stop.stopName.toLowerCase().includes(query.toLowerCase())) {\n                    locations.push({\n                        id: \"stop_\".concat(route.id, \"_\").concat(stop.stopName),\n                        name: stop.stopName,\n                        coordinates: [\n                            stop.longitude,\n                            stop.latitude\n                        ],\n                        type: 'bus_stop'\n                    });\n                }\n            });\n        });\n        return locations.slice(0, 10);\n    } catch (error) {\n        console.error('Error searching locations:', error);\n        return [];\n    }\n}\nasync function getAllRoutes() {\n    try {\n        const response = await fetch(\"\".concat(API_BASE, \"/routes\"));\n        if (!response.ok) throw new Error('Failed to fetch');\n        return await response.json();\n    } catch (error) {\n        console.error('Error fetching all routes:', error);\n        return [];\n    }\n}\nfunction calculateArrivalTime(durationMinutes) {\n    const now = new Date();\n    const arrival = new Date(now.getTime() + durationMinutes * 60000);\n    return arrival.toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNQyxVQUFVLElBQUlELEtBQUtELElBQUlHLE9BQU8sS0FBS0osa0JBQWtCO0lBQzNELE9BQU9HLFFBQVFFLGtCQUFrQixDQUFDLFNBQVM7UUFDekNDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxRQUFRO0lBQ1Y7QUFDRiIsInNvdXJjZXMiOlsiRDpcXEVkdWNhdGlvblxccGJ0c19zeXN0ZW1cXGFwcHNcXHBhc3NlbmdlclxcbGliXFxhcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRGlyZWN0IEFQSSBjYWxscyB0byBwYXNzZW5nZXIgYXBwJ3Mgb3duIHJvdXRlc1xuY29uc3QgQVBJX0JBU0UgPSAnL2FwaSdcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHJvdXRlTnVtYmVyOiBzdHJpbmc7XG4gIHJvdXRlTmFtZTogc3RyaW5nO1xuICBzdGFydExvY2F0aW9uOiBzdHJpbmc7XG4gIGVuZExvY2F0aW9uOiBzdHJpbmc7XG4gIGRpc3RhbmNlOiBudW1iZXI7XG4gIGVzdGltYXRlZER1cmF0aW9uOiBudW1iZXI7XG4gIGZhcmVQcmljZTogbnVtYmVyO1xuICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgc3RvcHM6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHN0b3BOYW1lOiBzdHJpbmc7XG4gICAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgICBsb25naXR1ZGU6IG51bWJlcjtcbiAgICBzdG9wT3JkZXI6IG51bWJlcjtcbiAgfT47XG4gIGN1cnJlbnRCdXNlcz86IEFycmF5PHtcbiAgICBpZDogbnVtYmVyO1xuICAgIGJ1c051bWJlcjogc3RyaW5nO1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIGxhdGl0dWRlPzogbnVtYmVyO1xuICAgIGxvbmdpdHVkZT86IG51bWJlcjtcbiAgfT47XG4gIG5leHREZXBhcnR1cmVzPzogQXJyYXk8e1xuICAgIGRlcGFydHVyZVRpbWU6IHN0cmluZztcbiAgICBidXNJZDogbnVtYmVyO1xuICB9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVNlYXJjaFJlc3VsdCB7XG4gIHJvdXRlOiBSb3V0ZTtcbiAgbmV4dERlcGFydHVyZXM6IEFycmF5PHtcbiAgICBkZXBhcnR1cmVUaW1lOiBzdHJpbmc7XG4gICAgYnVzSWQ6IG51bWJlcjtcbiAgfT47XG4gIGVzdGltYXRlZEFycml2YWw6IHN0cmluZztcbiAgY3VycmVudEJ1c2VzOiBBcnJheTx7XG4gICAgaWQ6IG51bWJlcjtcbiAgICBidXNOdW1iZXI6IHN0cmluZztcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICBsYXRpdHVkZT86IG51bWJlcjtcbiAgICBsb25naXR1ZGU/OiBudW1iZXI7XG4gIH0+O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoUm91dGVzKGZyb20/OiBzdHJpbmcsIHRvPzogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZVNlYXJjaFJlc3VsdFtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRX0vcm91dGVzYClcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCcpXG4gICAgXG4gICAgbGV0IHJvdXRlczogUm91dGVbXSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIFxuICAgIC8vIEZpbHRlciBieSBsb2NhdGlvbnMgaWYgcHJvdmlkZWRcbiAgICBpZiAoZnJvbSB8fCB0bykge1xuICAgICAgcm91dGVzID0gcm91dGVzLmZpbHRlcihyb3V0ZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXNGcm9tID0gIWZyb20gfHwgXG4gICAgICAgICAgcm91dGUuc3RhcnRMb2NhdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZyb20udG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICByb3V0ZS5zdG9wcy5zb21lKHN0b3AgPT4gc3RvcC5zdG9wTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZyb20udG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIGNvbnN0IG1hdGNoZXNUbyA9ICF0byB8fCBcbiAgICAgICAgICByb3V0ZS5lbmRMb2NhdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHRvLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgICAgcm91dGUuc3RvcHMuc29tZShzdG9wID0+IHN0b3Auc3RvcE5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0by50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNGcm9tICYmIG1hdGNoZXNUb1xuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJvdXRlcy5tYXAocm91dGUgPT4gKHtcbiAgICAgIHJvdXRlLFxuICAgICAgbmV4dERlcGFydHVyZXM6IFtcbiAgICAgICAgeyBkZXBhcnR1cmVUaW1lOiAnMDY6MDAnLCBidXNJZDogMSB9LFxuICAgICAgICB7IGRlcGFydHVyZVRpbWU6ICcwNjozMCcsIGJ1c0lkOiAxIH0sXG4gICAgICAgIHsgZGVwYXJ0dXJlVGltZTogJzA3OjAwJywgYnVzSWQ6IDEgfVxuICAgICAgXSxcbiAgICAgIGVzdGltYXRlZEFycml2YWw6IGNhbGN1bGF0ZUFycml2YWxUaW1lKHJvdXRlLmVzdGltYXRlZER1cmF0aW9uKSxcbiAgICAgIGN1cnJlbnRCdXNlczogW11cbiAgICB9KSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgcm91dGVzOicsIGVycm9yKVxuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNlYXJjaCByb3V0ZXMuIFBsZWFzZSBjaGVjayB5b3VyIGNvbm5lY3Rpb24uJylcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UG9wdWxhclJvdXRlcygpOiBQcm9taXNlPFJvdXRlW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9yb3V0ZXNgKVxuICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoJylcbiAgICBcbiAgICBjb25zdCByb3V0ZXM6IFJvdXRlW10gPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4gcm91dGVzLnNsaWNlKDAsIDYpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcG9wdWxhciByb3V0ZXM6JywgZXJyb3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBwb3B1bGFyIHJvdXRlcy4gUGxlYXNlIGNoZWNrIHlvdXIgY29ubmVjdGlvbi4nKVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSb3V0ZUJ5SWQoaWQ6IHN0cmluZyk6IFByb21pc2U8Um91dGUgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRX0vcm91dGVzYClcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCcpXG4gICAgXG4gICAgY29uc3Qgcm91dGVzOiBSb3V0ZVtdID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgcmV0dXJuIHJvdXRlcy5maW5kKHJvdXRlID0+IHJvdXRlLmlkID09PSBpZCkgfHwgbnVsbFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJvdXRlOicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNjaGVkdWxlc0J5Um91dGUocm91dGVJZDogc3RyaW5nKTogUHJvbWlzZTxhbnlbXT4ge1xuICB0cnkge1xuICAgIC8vIE1vY2sgc2NoZWR1bGVzIGZvciBub3cgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBzY2hlZHVsZSBBUEkgeWV0XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgaWQ6ICcxJyxcbiAgICAgICAgZGVwYXJ0dXJlVGltZTogJzA2OjAwJyxcbiAgICAgICAgYXJyaXZhbFRpbWU6ICcwNjozNScsXG4gICAgICAgIHN0YXR1czogJ1NDSEVEVUxFRCdcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAnMicsIFxuICAgICAgICBkZXBhcnR1cmVUaW1lOiAnMDY6MzAnLFxuICAgICAgICBhcnJpdmFsVGltZTogJzA3OjA1JyxcbiAgICAgICAgc3RhdHVzOiAnU0NIRURVTEVEJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgaWQ6ICczJyxcbiAgICAgICAgZGVwYXJ0dXJlVGltZTogJzA3OjAwJywgXG4gICAgICAgIGFycml2YWxUaW1lOiAnMDc6MzUnLFxuICAgICAgICBzdGF0dXM6ICdJTl9QUk9HUkVTUydcbiAgICAgIH1cbiAgICBdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc2NoZWR1bGVzOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdWJtaXRGZWVkYmFjayhmZWVkYmFjazoge1xuICBwYXNzZW5nZXJOYW1lOiBzdHJpbmc7XG4gIHBhc3NlbmdlckVtYWlsPzogc3RyaW5nO1xuICBwYXNzZW5nZXJQaG9uZT86IHN0cmluZztcbiAgcm91dGVJZD86IG51bWJlcjtcbiAgcmF0aW5nOiBudW1iZXI7XG4gIGNhdGVnb3J5OiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbn0pOiBQcm9taXNlPHsgaWQ6IG51bWJlcjsgbWVzc2FnZTogc3RyaW5nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9mZWVkYmFja2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICB9KVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBmZWVkYmFjazonLCBlcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzdWJtaXQgZmVlZGJhY2suIFBsZWFzZSB0cnkgYWdhaW4uJylcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlYWxMb2NhdGlvbkRhdGEge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIG5hbWVBbWhhcmljPzogc3RyaW5nO1xuICBjb29yZGluYXRlczogW251bWJlciwgbnVtYmVyXTtcbiAgYWRkcmVzcz86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlYXJjaExvY2F0aW9uU3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8UmVhbExvY2F0aW9uRGF0YVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgcm91dGVzID0gYXdhaXQgZ2V0QWxsUm91dGVzKCk7XG4gICAgY29uc3QgbG9jYXRpb25zOiBSZWFsTG9jYXRpb25EYXRhW10gPSBbXTtcbiAgICBcbiAgICByb3V0ZXMuZm9yRWFjaChyb3V0ZSA9PiB7XG4gICAgICBpZiAocm91dGUuc3RhcnRMb2NhdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxvY2F0aW9ucy5wdXNoKHtcbiAgICAgICAgICBpZDogYHJvdXRlX3N0YXJ0XyR7cm91dGUuaWR9YCxcbiAgICAgICAgICBuYW1lOiByb3V0ZS5zdGFydExvY2F0aW9uLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbMzguNzYzNiwgOS4wMDU0XSxcbiAgICAgICAgICB0eXBlOiAnYnVzX3N0YXRpb24nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJvdXRlLmVuZExvY2F0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgbG9jYXRpb25zLnB1c2goe1xuICAgICAgICAgIGlkOiBgcm91dGVfZW5kXyR7cm91dGUuaWR9YCxcbiAgICAgICAgICBuYW1lOiByb3V0ZS5lbmRMb2NhdGlvbixcbiAgICAgICAgICBjb29yZGluYXRlczogWzM4Ljc2MzYsIDkuMDA1NF0sXG4gICAgICAgICAgdHlwZTogJ2J1c19zdGF0aW9uJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJvdXRlLnN0b3BzPy5mb3JFYWNoKHN0b3AgPT4ge1xuICAgICAgICBpZiAoc3RvcC5zdG9wTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgbG9jYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGBzdG9wXyR7cm91dGUuaWR9XyR7c3RvcC5zdG9wTmFtZX1gLFxuICAgICAgICAgICAgbmFtZTogc3RvcC5zdG9wTmFtZSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbc3RvcC5sb25naXR1ZGUsIHN0b3AubGF0aXR1ZGVdLFxuICAgICAgICAgICAgdHlwZTogJ2J1c19zdG9wJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gbG9jYXRpb25zLnNsaWNlKDAsIDEwKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgbG9jYXRpb25zOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFJvdXRlcygpOiBQcm9taXNlPFJvdXRlW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9yb3V0ZXNgKVxuICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoJylcbiAgICBcbiAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWxsIHJvdXRlczonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVBcnJpdmFsVGltZShkdXJhdGlvbk1pbnV0ZXM6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGFycml2YWwgPSBuZXcgRGF0ZShub3cuZ2V0VGltZSgpICsgZHVyYXRpb25NaW51dGVzICogNjAwMDApO1xuICByZXR1cm4gYXJyaXZhbC50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLVVTJywgeyBcbiAgICBob3VyOiAnMi1kaWdpdCcsIFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIGhvdXIxMjogZmFsc2UgXG4gIH0pO1xufSJdLCJuYW1lcyI6WyJBUElfQkFTRSIsInNlYXJjaFJvdXRlcyIsImZyb20iLCJ0byIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwicm91dGVzIiwianNvbiIsImZpbHRlciIsInJvdXRlIiwibWF0Y2hlc0Zyb20iLCJzdGFydExvY2F0aW9uIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInN0b3BzIiwic29tZSIsInN0b3AiLCJzdG9wTmFtZSIsIm1hdGNoZXNUbyIsImVuZExvY2F0aW9uIiwibWFwIiwibmV4dERlcGFydHVyZXMiLCJkZXBhcnR1cmVUaW1lIiwiYnVzSWQiLCJlc3RpbWF0ZWRBcnJpdmFsIiwiY2FsY3VsYXRlQXJyaXZhbFRpbWUiLCJlc3RpbWF0ZWREdXJhdGlvbiIsImN1cnJlbnRCdXNlcyIsImVycm9yIiwiY29uc29sZSIsImdldFBvcHVsYXJSb3V0ZXMiLCJzbGljZSIsImdldFJvdXRlQnlJZCIsImlkIiwiZmluZCIsImdldFNjaGVkdWxlc0J5Um91dGUiLCJyb3V0ZUlkIiwiYXJyaXZhbFRpbWUiLCJzdGF0dXMiLCJzdWJtaXRGZWVkYmFjayIsImZlZWRiYWNrIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic2VhcmNoTG9jYXRpb25TdWdnZXN0aW9ucyIsInF1ZXJ5IiwiZ2V0QWxsUm91dGVzIiwibG9jYXRpb25zIiwiZm9yRWFjaCIsInB1c2giLCJuYW1lIiwiY29vcmRpbmF0ZXMiLCJ0eXBlIiwibG9uZ2l0dWRlIiwibGF0aXR1ZGUiLCJkdXJhdGlvbk1pbnV0ZXMiLCJub3ciLCJEYXRlIiwiYXJyaXZhbCIsImdldFRpbWUiLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyIiwibWludXRlIiwiaG91cjEyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/home/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllRoutes: () => (/* binding */ getAllRoutes),\n/* harmony export */   getPopularRoutes: () => (/* binding */ getPopularRoutes),\n/* harmony export */   getRouteById: () => (/* binding */ getRouteById),\n/* harmony export */   searchLocationSuggestions: () => (/* binding */ searchLocationSuggestions),\n/* harmony export */   searchRoutes: () => (/* binding */ searchRoutes),\n/* harmony export */   submitFeedback: () => (/* binding */ submitFeedback)\n/* harmony export */ });\n// Direct API calls to passenger app's own routes\nconst API_BASE = '/api';\nasync function searchRoutes(from, to) {\n    try {\n        const { data } = await apolloClient.query({\n            query: GET_ROUTES,\n            fetchPolicy: 'cache-first'\n        });\n        let routes = data.routes || [];\n        // Filter by locations if provided\n        if (from || to) {\n            routes = routes.filter((route)=>{\n                const matchesFrom = !from || route.startLocation.toLowerCase().includes(from.toLowerCase()) || route.stops.some((stop)=>stop.stopName.toLowerCase().includes(from.toLowerCase()));\n                const matchesTo = !to || route.endLocation.toLowerCase().includes(to.toLowerCase()) || route.stops.some((stop)=>stop.stopName.toLowerCase().includes(to.toLowerCase()));\n                return matchesFrom && matchesTo;\n            });\n        }\n        return routes.map((route)=>({\n                route,\n                nextDepartures: [\n                    {\n                        departureTime: '06:00',\n                        busId: 1\n                    },\n                    {\n                        departureTime: '06:30',\n                        busId: 1\n                    },\n                    {\n                        departureTime: '07:00',\n                        busId: 1\n                    }\n                ],\n                estimatedArrival: calculateArrivalTime(route.estimatedDuration),\n                currentBuses: []\n            }));\n    } catch (error) {\n        console.error('Error searching routes:', error);\n        throw new Error('Failed to search routes. Please check your connection.');\n    }\n}\nasync function getPopularRoutes() {\n    try {\n        const { data } = await apolloClient.query({\n            query: GET_ROUTES,\n            fetchPolicy: 'cache-first'\n        });\n        const routes = data.routes || [];\n        return routes.filter((route)=>route.isActive).slice(0, 6);\n    } catch (error) {\n        console.error('Error fetching popular routes:', error);\n        throw new Error('Failed to load popular routes. Please check your connection.');\n    }\n}\nasync function getRouteById(id) {\n    try {\n        const { data } = await apolloClient.query({\n            query: GET_ROUTE_BY_ID,\n            variables: {\n                id\n            },\n            fetchPolicy: 'cache-first'\n        });\n        return data.route || null;\n    } catch (error) {\n        console.error('Error fetching route:', error);\n        return null;\n    }\n}\nasync function submitFeedback(feedback) {\n    try {\n        const response = await fetch(\"\".concat(API_BASE_URL, \"/feedback\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(feedback)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        return await response.json();\n    } catch (error) {\n        console.error('Error submitting feedback:', error);\n        throw new Error('Failed to submit feedback. Please try again.');\n    }\n}\nasync function searchLocationSuggestions(query) {\n    try {\n        const routes = await getAllRoutes();\n        const locations = [];\n        routes.forEach((route)=>{\n            var _route_stops;\n            if (route.startLocation.toLowerCase().includes(query.toLowerCase())) {\n                locations.push({\n                    id: \"route_start_\".concat(route.id),\n                    name: route.startLocation,\n                    coordinates: [\n                        38.7636,\n                        9.0054\n                    ],\n                    type: 'bus_station'\n                });\n            }\n            if (route.endLocation.toLowerCase().includes(query.toLowerCase())) {\n                locations.push({\n                    id: \"route_end_\".concat(route.id),\n                    name: route.endLocation,\n                    coordinates: [\n                        38.7636,\n                        9.0054\n                    ],\n                    type: 'bus_station'\n                });\n            }\n            (_route_stops = route.stops) === null || _route_stops === void 0 ? void 0 : _route_stops.forEach((stop)=>{\n                if (stop.stopName.toLowerCase().includes(query.toLowerCase())) {\n                    locations.push({\n                        id: \"stop_\".concat(route.id, \"_\").concat(stop.stopName),\n                        name: stop.stopName,\n                        coordinates: [\n                            stop.longitude,\n                            stop.latitude\n                        ],\n                        type: 'bus_stop'\n                    });\n                }\n            });\n        });\n        return locations.slice(0, 10);\n    } catch (error) {\n        console.error('Error searching locations:', error);\n        return [];\n    }\n}\nasync function getAllRoutes() {\n    try {\n        const { data } = await apolloClient.query({\n            query: GET_ROUTES,\n            fetchPolicy: 'cache-first'\n        });\n        return data.routes || [];\n    } catch (error) {\n        console.error('Error fetching all routes:', error);\n        return [];\n    }\n}\nfunction calculateArrivalTime(durationMinutes) {\n    const now = new Date();\n    const arrival = new Date(now.getTime() + durationMinutes * 60000);\n    return arrival.toLocaleTimeString('en-US', {\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUMsS0FBaUIsT0FBZG5CLEtBQUtDLFFBQVE7d0JBQ3JDdUMsTUFBTXhDLEtBQUtDLFFBQVE7d0JBQ25Cd0MsYUFBYTs0QkFBQ3pDLEtBQUsyQyxTQUFTOzRCQUFFM0MsS0FBSzRDLFFBQVE7eUJBQUM7d0JBQzVDRixNQUFNO29CQUNSO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU9MLFVBQVVwQixLQUFLLENBQUMsR0FBRztJQUM1QixFQUFFLE9BQU9MLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDhCQUE4QkE7UUFDNUMsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVPLGVBQWV3QjtJQUNwQixJQUFJO1FBQ0YsTUFBTSxFQUFFbEQsSUFBSSxFQUFFLEdBQUcsTUFBTUMsYUFBYUMsS0FBSyxDQUFDO1lBQ3hDQSxPQUFPQztZQUNQQyxhQUFhO1FBQ2Y7UUFFQSxPQUFPSixLQUFLSyxNQUFNLElBQUksRUFBRTtJQUMxQixFQUFFLE9BQU9xQixPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyw4QkFBOEJBO1FBQzVDLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQSxTQUFTSCxxQkFBcUJvQyxlQUF1QjtJQUNuRCxNQUFNQyxNQUFNLElBQUlDO0lBQ2hCLE1BQU1DLFVBQVUsSUFBSUQsS0FBS0QsSUFBSUcsT0FBTyxLQUFLSixrQkFBa0I7SUFDM0QsT0FBT0csUUFBUUUsa0JBQWtCLENBQUMsU0FBUztRQUN6Q0MsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLFFBQVE7SUFDVjtBQUNGIiwic291cmNlcyI6WyJEOlxcRWR1Y2F0aW9uXFxwYnRzX3N5c3RlbVxcYXBwc1xccGFzc2VuZ2VyXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEaXJlY3QgQVBJIGNhbGxzIHRvIHBhc3NlbmdlciBhcHAncyBvd24gcm91dGVzXG5jb25zdCBBUElfQkFTRSA9ICcvYXBpJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlIHtcbiAgaWQ6IHN0cmluZztcbiAgcm91dGVOdW1iZXI6IHN0cmluZztcbiAgcm91dGVOYW1lOiBzdHJpbmc7XG4gIHN0YXJ0TG9jYXRpb246IHN0cmluZztcbiAgZW5kTG9jYXRpb246IHN0cmluZztcbiAgZGlzdGFuY2U6IG51bWJlcjtcbiAgZXN0aW1hdGVkRHVyYXRpb246IG51bWJlcjtcbiAgZmFyZVByaWNlOiBudW1iZXI7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBzdG9wczogQXJyYXk8e1xuICAgIGlkOiBzdHJpbmc7XG4gICAgc3RvcE5hbWU6IHN0cmluZztcbiAgICBsYXRpdHVkZTogbnVtYmVyO1xuICAgIGxvbmdpdHVkZTogbnVtYmVyO1xuICAgIHN0b3BPcmRlcjogbnVtYmVyO1xuICB9PjtcbiAgY3VycmVudEJ1c2VzPzogQXJyYXk8e1xuICAgIGlkOiBudW1iZXI7XG4gICAgYnVzTnVtYmVyOiBzdHJpbmc7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgbGF0aXR1ZGU/OiBudW1iZXI7XG4gICAgbG9uZ2l0dWRlPzogbnVtYmVyO1xuICB9PjtcbiAgbmV4dERlcGFydHVyZXM/OiBBcnJheTx7XG4gICAgZGVwYXJ0dXJlVGltZTogc3RyaW5nO1xuICAgIGJ1c0lkOiBudW1iZXI7XG4gIH0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlU2VhcmNoUmVzdWx0IHtcbiAgcm91dGU6IFJvdXRlO1xuICBuZXh0RGVwYXJ0dXJlczogQXJyYXk8e1xuICAgIGRlcGFydHVyZVRpbWU6IHN0cmluZztcbiAgICBidXNJZDogbnVtYmVyO1xuICB9PjtcbiAgZXN0aW1hdGVkQXJyaXZhbDogc3RyaW5nO1xuICBjdXJyZW50QnVzZXM6IEFycmF5PHtcbiAgICBpZDogbnVtYmVyO1xuICAgIGJ1c051bWJlcjogc3RyaW5nO1xuICAgIHN0YXR1czogc3RyaW5nO1xuICAgIGxhdGl0dWRlPzogbnVtYmVyO1xuICAgIGxvbmdpdHVkZT86IG51bWJlcjtcbiAgfT47XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hSb3V0ZXMoZnJvbT86IHN0cmluZywgdG8/OiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlU2VhcmNoUmVzdWx0W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwb2xsb0NsaWVudC5xdWVyeSh7XG4gICAgICBxdWVyeTogR0VUX1JPVVRFUyxcbiAgICAgIGZldGNoUG9saWN5OiAnY2FjaGUtZmlyc3QnXG4gICAgfSlcbiAgICBcbiAgICBsZXQgcm91dGVzOiBSb3V0ZVtdID0gZGF0YS5yb3V0ZXMgfHwgW11cbiAgICBcbiAgICAvLyBGaWx0ZXIgYnkgbG9jYXRpb25zIGlmIHByb3ZpZGVkXG4gICAgaWYgKGZyb20gfHwgdG8pIHtcbiAgICAgIHJvdXRlcyA9IHJvdXRlcy5maWx0ZXIocm91dGUgPT4ge1xuICAgICAgICBjb25zdCBtYXRjaGVzRnJvbSA9ICFmcm9tIHx8IFxuICAgICAgICAgIHJvdXRlLnN0YXJ0TG9jYXRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmcm9tLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICAgICAgcm91dGUuc3RvcHMuc29tZShzdG9wID0+IHN0b3Auc3RvcE5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmcm9tLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICBjb25zdCBtYXRjaGVzVG8gPSAhdG8gfHwgXG4gICAgICAgICAgcm91dGUuZW5kTG9jYXRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0by50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgIHJvdXRlLnN0b3BzLnNvbWUoc3RvcCA9PiBzdG9wLnN0b3BOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXModG8udG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIHJldHVybiBtYXRjaGVzRnJvbSAmJiBtYXRjaGVzVG9cbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIHJldHVybiByb3V0ZXMubWFwKHJvdXRlID0+ICh7XG4gICAgICByb3V0ZSxcbiAgICAgIG5leHREZXBhcnR1cmVzOiBbXG4gICAgICAgIHsgZGVwYXJ0dXJlVGltZTogJzA2OjAwJywgYnVzSWQ6IDEgfSxcbiAgICAgICAgeyBkZXBhcnR1cmVUaW1lOiAnMDY6MzAnLCBidXNJZDogMSB9LFxuICAgICAgICB7IGRlcGFydHVyZVRpbWU6ICcwNzowMCcsIGJ1c0lkOiAxIH1cbiAgICAgIF0sXG4gICAgICBlc3RpbWF0ZWRBcnJpdmFsOiBjYWxjdWxhdGVBcnJpdmFsVGltZShyb3V0ZS5lc3RpbWF0ZWREdXJhdGlvbiksXG4gICAgICBjdXJyZW50QnVzZXM6IFtdXG4gICAgfSkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIHJvdXRlczonLCBlcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggcm91dGVzLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBvcHVsYXJSb3V0ZXMoKTogUHJvbWlzZTxSb3V0ZVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcG9sbG9DbGllbnQucXVlcnkoe1xuICAgICAgcXVlcnk6IEdFVF9ST1VURVMsXG4gICAgICBmZXRjaFBvbGljeTogJ2NhY2hlLWZpcnN0J1xuICAgIH0pXG4gICAgXG4gICAgY29uc3Qgcm91dGVzOiBSb3V0ZVtdID0gZGF0YS5yb3V0ZXMgfHwgW11cbiAgICByZXR1cm4gcm91dGVzLmZpbHRlcihyb3V0ZSA9PiByb3V0ZS5pc0FjdGl2ZSkuc2xpY2UoMCwgNilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwb3B1bGFyIHJvdXRlczonLCBlcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHBvcHVsYXIgcm91dGVzLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJvdXRlQnlJZChpZDogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwb2xsb0NsaWVudC5xdWVyeSh7XG4gICAgICBxdWVyeTogR0VUX1JPVVRFX0JZX0lELFxuICAgICAgdmFyaWFibGVzOiB7IGlkIH0sXG4gICAgICBmZXRjaFBvbGljeTogJ2NhY2hlLWZpcnN0J1xuICAgIH0pXG4gICAgXG4gICAgcmV0dXJuIGRhdGEucm91dGUgfHwgbnVsbFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJvdXRlOicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN1Ym1pdEZlZWRiYWNrKGZlZWRiYWNrOiB7XG4gIHBhc3Nlbmdlck5hbWU6IHN0cmluZztcbiAgcGFzc2VuZ2VyRW1haWw/OiBzdHJpbmc7XG4gIHBhc3NlbmdlclBob25lPzogc3RyaW5nO1xuICByb3V0ZUlkPzogbnVtYmVyO1xuICByYXRpbmc6IG51bWJlcjtcbiAgY2F0ZWdvcnk6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xufSk6IFByb21pc2U8eyBpZDogbnVtYmVyOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9mZWVkYmFja2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBmZWVkYmFjazonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc3VibWl0IGZlZWRiYWNrLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVhbExvY2F0aW9uRGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgbmFtZUFtaGFyaWM/OiBzdHJpbmc7XG4gIGNvb3JkaW5hdGVzOiBbbnVtYmVyLCBudW1iZXJdO1xuICBhZGRyZXNzPzogc3RyaW5nO1xuICB0eXBlPzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoTG9jYXRpb25TdWdnZXN0aW9ucyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxSZWFsTG9jYXRpb25EYXRhW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByb3V0ZXMgPSBhd2FpdCBnZXRBbGxSb3V0ZXMoKTtcbiAgICBjb25zdCBsb2NhdGlvbnM6IFJlYWxMb2NhdGlvbkRhdGFbXSA9IFtdO1xuICAgIFxuICAgIHJvdXRlcy5mb3JFYWNoKHJvdXRlID0+IHtcbiAgICAgIGlmIChyb3V0ZS5zdGFydExvY2F0aW9uLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgbG9jYXRpb25zLnB1c2goe1xuICAgICAgICAgIGlkOiBgcm91dGVfc3RhcnRfJHtyb3V0ZS5pZH1gLFxuICAgICAgICAgIG5hbWU6IHJvdXRlLnN0YXJ0TG9jYXRpb24sXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFszOC43NjM2LCA5LjAwNTRdLFxuICAgICAgICAgIHR5cGU6ICdidXNfc3RhdGlvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocm91dGUuZW5kTG9jYXRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBsb2NhdGlvbnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGByb3V0ZV9lbmRfJHtyb3V0ZS5pZH1gLFxuICAgICAgICAgIG5hbWU6IHJvdXRlLmVuZExvY2F0aW9uLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbMzguNzYzNiwgOS4wMDU0XSxcbiAgICAgICAgICB0eXBlOiAnYnVzX3N0YXRpb24nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcm91dGUuc3RvcHM/LmZvckVhY2goc3RvcCA9PiB7XG4gICAgICAgIGlmIChzdG9wLnN0b3BOYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICBsb2NhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBpZDogYHN0b3BfJHtyb3V0ZS5pZH1fJHtzdG9wLnN0b3BOYW1lfWAsXG4gICAgICAgICAgICBuYW1lOiBzdG9wLnN0b3BOYW1lLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtzdG9wLmxvbmdpdHVkZSwgc3RvcC5sYXRpdHVkZV0sXG4gICAgICAgICAgICB0eXBlOiAnYnVzX3N0b3AnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBsb2NhdGlvbnMuc2xpY2UoMCwgMTApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlYXJjaGluZyBsb2NhdGlvbnM6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsUm91dGVzKCk6IFByb21pc2U8Um91dGVbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBvbGxvQ2xpZW50LnF1ZXJ5KHtcbiAgICAgIHF1ZXJ5OiBHRVRfUk9VVEVTLFxuICAgICAgZmV0Y2hQb2xpY3k6ICdjYWNoZS1maXJzdCdcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBkYXRhLnJvdXRlcyB8fCBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFsbCByb3V0ZXM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQXJyaXZhbFRpbWUoZHVyYXRpb25NaW51dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCBhcnJpdmFsID0gbmV3IERhdGUobm93LmdldFRpbWUoKSArIGR1cmF0aW9uTWludXRlcyAqIDYwMDAwKTtcbiAgcmV0dXJuIGFycml2YWwudG9Mb2NhbGVUaW1lU3RyaW5nKCdlbi1VUycsIHsgXG4gICAgaG91cjogJzItZGlnaXQnLCBcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBob3VyMTI6IGZhbHNlIFxuICB9KTtcbn0iXSwibmFtZXMiOlsiQVBJX0JBU0UiLCJzZWFyY2hSb3V0ZXMiLCJmcm9tIiwidG8iLCJkYXRhIiwiYXBvbGxvQ2xpZW50IiwicXVlcnkiLCJHRVRfUk9VVEVTIiwiZmV0Y2hQb2xpY3kiLCJyb3V0ZXMiLCJmaWx0ZXIiLCJyb3V0ZSIsIm1hdGNoZXNGcm9tIiwic3RhcnRMb2NhdGlvbiIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJzdG9wcyIsInNvbWUiLCJzdG9wIiwic3RvcE5hbWUiLCJtYXRjaGVzVG8iLCJlbmRMb2NhdGlvbiIsIm1hcCIsIm5leHREZXBhcnR1cmVzIiwiZGVwYXJ0dXJlVGltZSIsImJ1c0lkIiwiZXN0aW1hdGVkQXJyaXZhbCIsImNhbGN1bGF0ZUFycml2YWxUaW1lIiwiZXN0aW1hdGVkRHVyYXRpb24iLCJjdXJyZW50QnVzZXMiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsImdldFBvcHVsYXJSb3V0ZXMiLCJpc0FjdGl2ZSIsInNsaWNlIiwiZ2V0Um91dGVCeUlkIiwiaWQiLCJHRVRfUk9VVEVfQllfSUQiLCJ2YXJpYWJsZXMiLCJzdWJtaXRGZWVkYmFjayIsImZlZWRiYWNrIiwicmVzcG9uc2UiLCJmZXRjaCIsIkFQSV9CQVNFX1VSTCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwic3RhdHVzIiwianNvbiIsInNlYXJjaExvY2F0aW9uU3VnZ2VzdGlvbnMiLCJnZXRBbGxSb3V0ZXMiLCJsb2NhdGlvbnMiLCJmb3JFYWNoIiwicHVzaCIsIm5hbWUiLCJjb29yZGluYXRlcyIsInR5cGUiLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsImR1cmF0aW9uTWludXRlcyIsIm5vdyIsIkRhdGUiLCJhcnJpdmFsIiwiZ2V0VGltZSIsInRvTG9jYWxlVGltZVN0cmluZyIsImhvdXIiLCJtaW51dGUiLCJob3VyMTIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/to-buffer";
exports.ids = ["vendor-chunks/to-buffer"];
exports.modules = {

/***/ "(rsc)/../../node_modules/to-buffer/index.js":
/*!*********************************************!*\
  !*** ../../node_modules/to-buffer/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/../../node_modules/safe-buffer/index.js\").Buffer);\nvar isArray = __webpack_require__(/*! isarray */ \"(rsc)/../../node_modules/isarray/index.js\");\nvar typedArrayBuffer = __webpack_require__(/*! typed-array-buffer */ \"(rsc)/../../node_modules/typed-array-buffer/index.js\");\nvar isView = ArrayBuffer.isView || function isView(obj) {\n    try {\n        typedArrayBuffer(obj);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\nvar useUint8Array = typeof Uint8Array !== \"undefined\";\nvar useArrayBuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\nvar useFromArrayBuffer = useArrayBuffer && (Buffer.prototype instanceof Uint8Array || Buffer.TYPED_ARRAY_SUPPORT);\nmodule.exports = function toBuffer(data, encoding) {\n    if (Buffer.isBuffer(data)) {\n        if (data.constructor && !(\"isBuffer\" in data)) {\n            // probably a SlowBuffer\n            return Buffer.from(data);\n        }\n        return data;\n    }\n    if (typeof data === \"string\") {\n        return Buffer.from(data, encoding);\n    }\n    /*\n\t * Wrap any TypedArray instances and DataViews\n\t * Makes sense only on engines with full TypedArray support -- let Buffer detect that\n\t */ if (useArrayBuffer && isView(data)) {\n        // Bug in Node.js <6.3.1, which treats this as out-of-bounds\n        if (data.byteLength === 0) {\n            return Buffer.alloc(0);\n        }\n        // When Buffer is based on Uint8Array, we can just construct it from ArrayBuffer\n        if (useFromArrayBuffer) {\n            var res = Buffer.from(data.buffer, data.byteOffset, data.byteLength);\n            /*\n\t\t\t * Recheck result size, as offset/length doesn't work on Node.js <5.10\n\t\t\t * We just go to Uint8Array case if this fails\n\t\t\t */ if (res.byteLength === data.byteLength) {\n                return res;\n            }\n        }\n        // Convert to Uint8Array bytes and then to Buffer\n        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        var result = Buffer.from(uint8);\n        /*\n\t\t * Let's recheck that conversion succeeded\n\t\t * We have .length but not .byteLength when useFromArrayBuffer is false\n\t\t */ if (result.length === data.byteLength) {\n            return result;\n        }\n    }\n    /*\n\t * Uint8Array in engines where Buffer.from might not work with ArrayBuffer, just copy over\n\t * Doesn't make sense with other TypedArray instances\n\t */ if (useUint8Array && data instanceof Uint8Array) {\n        return Buffer.from(data);\n    }\n    var isArr = isArray(data);\n    if (isArr) {\n        for(var i = 0; i < data.length; i += 1){\n            var x = data[i];\n            if (typeof x !== \"number\" || x < 0 || x > 255 || ~~x !== x // NaN and integer check\n            ) {\n                throw new RangeError(\"Array items must be numbers in the range 0-255.\");\n            }\n        }\n    }\n    /*\n\t * Old Buffer polyfill on an engine that doesn't have TypedArray support\n\t * Also, this is from a different Buffer polyfill implementation then we have, as instanceof check failed\n\t * Convert to our current Buffer implementation\n\t */ if (isArr || Buffer.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === \"function\" && data.constructor.isBuffer(data)) {\n        return Buffer.from(data);\n    }\n    throw new TypeError('The \"data\" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3RvLWJ1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFNBQVNDLGdHQUE2QjtBQUMxQyxJQUFJQyxVQUFVRCxtQkFBT0EsQ0FBQztBQUN0QixJQUFJRSxtQkFBbUJGLG1CQUFPQSxDQUFDO0FBRS9CLElBQUlHLFNBQVNDLFlBQVlELE1BQU0sSUFBSSxTQUFTQSxPQUFPRSxHQUFHO0lBQ3JELElBQUk7UUFDSEgsaUJBQWlCRztRQUNqQixPQUFPO0lBQ1IsRUFBRSxPQUFPQyxHQUFHO1FBQ1gsT0FBTztJQUNSO0FBQ0Q7QUFFQSxJQUFJQyxnQkFBZ0IsT0FBT0MsZUFBZTtBQUMxQyxJQUFJQyxpQkFBaUIsT0FBT0wsZ0JBQWdCLGVBQ3hDLE9BQU9JLGVBQWU7QUFDMUIsSUFBSUUscUJBQXFCRCxrQkFBbUJWLENBQUFBLE9BQU9ZLFNBQVMsWUFBWUgsY0FBY1QsT0FBT2EsbUJBQW1CO0FBRWhIQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsU0FBU0MsSUFBSSxFQUFFQyxRQUFRO0lBQ2hELElBQUlsQixPQUFPbUIsUUFBUSxDQUFDRixPQUFPO1FBQzFCLElBQUlBLEtBQUtHLFdBQVcsSUFBSSxDQUFFLGVBQWNILElBQUcsR0FBSTtZQUM5Qyx3QkFBd0I7WUFDeEIsT0FBT2pCLE9BQU9xQixJQUFJLENBQUNKO1FBQ3BCO1FBQ0EsT0FBT0E7SUFDUjtJQUVBLElBQUksT0FBT0EsU0FBUyxVQUFVO1FBQzdCLE9BQU9qQixPQUFPcUIsSUFBSSxDQUFDSixNQUFNQztJQUMxQjtJQUVBOzs7RUFHQyxHQUNELElBQUlSLGtCQUFrQk4sT0FBT2EsT0FBTztRQUNuQyw0REFBNEQ7UUFDNUQsSUFBSUEsS0FBS0ssVUFBVSxLQUFLLEdBQUc7WUFDMUIsT0FBT3RCLE9BQU91QixLQUFLLENBQUM7UUFDckI7UUFFQSxnRkFBZ0Y7UUFDaEYsSUFBSVosb0JBQW9CO1lBQ3ZCLElBQUlhLE1BQU14QixPQUFPcUIsSUFBSSxDQUFDSixLQUFLUSxNQUFNLEVBQUVSLEtBQUtTLFVBQVUsRUFBRVQsS0FBS0ssVUFBVTtZQUNuRTs7O0lBR0MsR0FDRCxJQUFJRSxJQUFJRixVQUFVLEtBQUtMLEtBQUtLLFVBQVUsRUFBRTtnQkFDdkMsT0FBT0U7WUFDUjtRQUNEO1FBRUEsaURBQWlEO1FBQ2pELElBQUlHLFFBQVFWLGdCQUFnQlIsYUFBYVEsT0FBTyxJQUFJUixXQUFXUSxLQUFLUSxNQUFNLEVBQUVSLEtBQUtTLFVBQVUsRUFBRVQsS0FBS0ssVUFBVTtRQUM1RyxJQUFJTSxTQUFTNUIsT0FBT3FCLElBQUksQ0FBQ007UUFFekI7OztHQUdDLEdBQ0QsSUFBSUMsT0FBT0MsTUFBTSxLQUFLWixLQUFLSyxVQUFVLEVBQUU7WUFDdEMsT0FBT007UUFDUjtJQUNEO0lBRUE7OztFQUdDLEdBQ0QsSUFBSXBCLGlCQUFpQlMsZ0JBQWdCUixZQUFZO1FBQ2hELE9BQU9ULE9BQU9xQixJQUFJLENBQUNKO0lBQ3BCO0lBRUEsSUFBSWEsUUFBUTVCLFFBQVFlO0lBQ3BCLElBQUlhLE9BQU87UUFDVixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWQsS0FBS1ksTUFBTSxFQUFFRSxLQUFLLEVBQUc7WUFDeEMsSUFBSUMsSUFBSWYsSUFBSSxDQUFDYyxFQUFFO1lBQ2YsSUFDQyxPQUFPQyxNQUFNLFlBQ1ZBLElBQUksS0FDSkEsSUFBSSxPQUNKLENBQUMsQ0FBQ0EsTUFBTUEsRUFBRSx3QkFBd0I7Y0FDcEM7Z0JBQ0QsTUFBTSxJQUFJQyxXQUFXO1lBQ3RCO1FBQ0Q7SUFDRDtJQUVBOzs7O0VBSUMsR0FDRCxJQUNDSCxTQUNDOUIsT0FBT21CLFFBQVEsQ0FBQ0YsU0FDYkEsS0FBS0csV0FBVyxJQUNoQixPQUFPSCxLQUFLRyxXQUFXLENBQUNELFFBQVEsS0FBSyxjQUNyQ0YsS0FBS0csV0FBVyxDQUFDRCxRQUFRLENBQUNGLE9BRTdCO1FBQ0QsT0FBT2pCLE9BQU9xQixJQUFJLENBQUNKO0lBQ3BCO0lBRUEsTUFBTSxJQUFJaUIsVUFBVTtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3BidHMtYWRtaW4vLi4vLi4vbm9kZV9tb2R1bGVzL3RvLWJ1ZmZlci9pbmRleC5qcz82MmE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgdHlwZWRBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJ3R5cGVkLWFycmF5LWJ1ZmZlcicpO1xuXG52YXIgaXNWaWV3ID0gQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uIGlzVmlldyhvYmopIHtcblx0dHJ5IHtcblx0XHR0eXBlZEFycmF5QnVmZmVyKG9iaik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbnZhciB1c2VVaW50OEFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnO1xudmFyIHVzZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuXHQmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgdXNlRnJvbUFycmF5QnVmZmVyID0gdXNlQXJyYXlCdWZmZXIgJiYgKEJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0J1ZmZlcihkYXRhLCBlbmNvZGluZykge1xuXHRpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG5cdFx0aWYgKGRhdGEuY29uc3RydWN0b3IgJiYgISgnaXNCdWZmZXInIGluIGRhdGEpKSB7XG5cdFx0XHQvLyBwcm9iYWJseSBhIFNsb3dCdWZmZXJcblx0XHRcdHJldHVybiBCdWZmZXIuZnJvbShkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cblxuXHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcblx0fVxuXG5cdC8qXG5cdCAqIFdyYXAgYW55IFR5cGVkQXJyYXkgaW5zdGFuY2VzIGFuZCBEYXRhVmlld3Ncblx0ICogTWFrZXMgc2Vuc2Ugb25seSBvbiBlbmdpbmVzIHdpdGggZnVsbCBUeXBlZEFycmF5IHN1cHBvcnQgLS0gbGV0IEJ1ZmZlciBkZXRlY3QgdGhhdFxuXHQgKi9cblx0aWYgKHVzZUFycmF5QnVmZmVyICYmIGlzVmlldyhkYXRhKSkge1xuXHRcdC8vIEJ1ZyBpbiBOb2RlLmpzIDw2LjMuMSwgd2hpY2ggdHJlYXRzIHRoaXMgYXMgb3V0LW9mLWJvdW5kc1xuXHRcdGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiBCdWZmZXIgaXMgYmFzZWQgb24gVWludDhBcnJheSwgd2UgY2FuIGp1c3QgY29uc3RydWN0IGl0IGZyb20gQXJyYXlCdWZmZXJcblx0XHRpZiAodXNlRnJvbUFycmF5QnVmZmVyKSB7XG5cdFx0XHR2YXIgcmVzID0gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcblx0XHRcdC8qXG5cdFx0XHQgKiBSZWNoZWNrIHJlc3VsdCBzaXplLCBhcyBvZmZzZXQvbGVuZ3RoIGRvZXNuJ3Qgd29yayBvbiBOb2RlLmpzIDw1LjEwXG5cdFx0XHQgKiBXZSBqdXN0IGdvIHRvIFVpbnQ4QXJyYXkgY2FzZSBpZiB0aGlzIGZhaWxzXG5cdFx0XHQgKi9cblx0XHRcdGlmIChyZXMuYnl0ZUxlbmd0aCA9PT0gZGF0YS5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCB0byBVaW50OEFycmF5IGJ5dGVzIGFuZCB0aGVuIHRvIEJ1ZmZlclxuXHRcdHZhciB1aW50OCA9IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gZGF0YSA6IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG5cdFx0dmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHVpbnQ4KTtcblxuXHRcdC8qXG5cdFx0ICogTGV0J3MgcmVjaGVjayB0aGF0IGNvbnZlcnNpb24gc3VjY2VlZGVkXG5cdFx0ICogV2UgaGF2ZSAubGVuZ3RoIGJ1dCBub3QgLmJ5dGVMZW5ndGggd2hlbiB1c2VGcm9tQXJyYXlCdWZmZXIgaXMgZmFsc2Vcblx0XHQgKi9cblx0XHRpZiAocmVzdWx0Lmxlbmd0aCA9PT0gZGF0YS5ieXRlTGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCAqIFVpbnQ4QXJyYXkgaW4gZW5naW5lcyB3aGVyZSBCdWZmZXIuZnJvbSBtaWdodCBub3Qgd29yayB3aXRoIEFycmF5QnVmZmVyLCBqdXN0IGNvcHkgb3ZlclxuXHQgKiBEb2Vzbid0IG1ha2Ugc2Vuc2Ugd2l0aCBvdGhlciBUeXBlZEFycmF5IGluc3RhbmNlc1xuXHQgKi9cblx0aWYgKHVzZVVpbnQ4QXJyYXkgJiYgZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmZyb20oZGF0YSk7XG5cdH1cblxuXHR2YXIgaXNBcnIgPSBpc0FycmF5KGRhdGEpO1xuXHRpZiAoaXNBcnIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdHZhciB4ID0gZGF0YVtpXTtcblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIHggIT09ICdudW1iZXInXG5cdFx0XHRcdHx8IHggPCAwXG5cdFx0XHRcdHx8IHggPiAyNTVcblx0XHRcdFx0fHwgfn54ICE9PSB4IC8vIE5hTiBhbmQgaW50ZWdlciBjaGVja1xuXHRcdFx0KSB7XG5cdFx0XHRcdHRocm93IG5ldyBSYW5nZUVycm9yKCdBcnJheSBpdGVtcyBtdXN0IGJlIG51bWJlcnMgaW4gdGhlIHJhbmdlIDAtMjU1LicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qXG5cdCAqIE9sZCBCdWZmZXIgcG9seWZpbGwgb24gYW4gZW5naW5lIHRoYXQgZG9lc24ndCBoYXZlIFR5cGVkQXJyYXkgc3VwcG9ydFxuXHQgKiBBbHNvLCB0aGlzIGlzIGZyb20gYSBkaWZmZXJlbnQgQnVmZmVyIHBvbHlmaWxsIGltcGxlbWVudGF0aW9uIHRoZW4gd2UgaGF2ZSwgYXMgaW5zdGFuY2VvZiBjaGVjayBmYWlsZWRcblx0ICogQ29udmVydCB0byBvdXIgY3VycmVudCBCdWZmZXIgaW1wbGVtZW50YXRpb25cblx0ICovXG5cdGlmIChcblx0XHRpc0FyciB8fCAoXG5cdFx0XHRCdWZmZXIuaXNCdWZmZXIoZGF0YSlcblx0XHRcdCYmIGRhdGEuY29uc3RydWN0b3Jcblx0XHRcdCYmIHR5cGVvZiBkYXRhLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nXG5cdFx0XHQmJiBkYXRhLmNvbnN0cnVjdG9yLmlzQnVmZmVyKGRhdGEpXG5cdFx0KVxuXHQpIHtcblx0XHRyZXR1cm4gQnVmZmVyLmZyb20oZGF0YSk7XG5cdH1cblxuXHR0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJkYXRhXCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgYW4gQXJyYXksIGEgQnVmZmVyLCBhIFVpbnQ4QXJyYXksIG9yIGEgRGF0YVZpZXcuJyk7XG59O1xuIl0sIm5hbWVzIjpbIkJ1ZmZlciIsInJlcXVpcmUiLCJpc0FycmF5IiwidHlwZWRBcnJheUJ1ZmZlciIsImlzVmlldyIsIkFycmF5QnVmZmVyIiwib2JqIiwiZSIsInVzZVVpbnQ4QXJyYXkiLCJVaW50OEFycmF5IiwidXNlQXJyYXlCdWZmZXIiLCJ1c2VGcm9tQXJyYXlCdWZmZXIiLCJwcm90b3R5cGUiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwibW9kdWxlIiwiZXhwb3J0cyIsInRvQnVmZmVyIiwiZGF0YSIsImVuY29kaW5nIiwiaXNCdWZmZXIiLCJjb25zdHJ1Y3RvciIsImZyb20iLCJieXRlTGVuZ3RoIiwiYWxsb2MiLCJyZXMiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwidWludDgiLCJyZXN1bHQiLCJsZW5ndGgiLCJpc0FyciIsImkiLCJ4IiwiUmFuZ2VFcnJvciIsIlR5cGVFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/to-buffer/index.js\n");

/***/ })

};
;
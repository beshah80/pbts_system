"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/zen-observable-ts";
exports.ids = ["vendor-chunks/zen-observable-ts"];
exports.modules = {

/***/ "(ssr)/../../node_modules/zen-observable-ts/module.js":
/*!******************************************************!*\
  !*** ../../node_modules/zen-observable-ts/module.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Observable: () => (/* binding */ Observable)\n/* harmony export */ });\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) return {\n                done: true\n            };\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n        writable: false\n    });\n    return Constructor;\n}\n// === Symbol Support ===\nvar hasSymbols = function() {\n    return typeof Symbol === \"function\";\n};\nvar hasSymbol = function(name) {\n    return hasSymbols() && Boolean(Symbol[name]);\n};\nvar getSymbol = function(name) {\n    return hasSymbol(name) ? Symbol[name] : \"@@\" + name;\n};\nif (hasSymbols() && !hasSymbol(\"observable\")) {\n    Symbol.observable = Symbol(\"observable\");\n}\nvar SymbolIterator = getSymbol(\"iterator\");\nvar SymbolObservable = getSymbol(\"observable\");\nvar SymbolSpecies = getSymbol(\"species\"); // === Abstract Operations ===\nfunction getMethod(obj, key) {\n    var value = obj[key];\n    if (value == null) return undefined;\n    if (typeof value !== \"function\") throw new TypeError(value + \" is not a function\");\n    return value;\n}\nfunction getSpecies(obj) {\n    var ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(e) {\n    if (hostReportError.log) {\n        hostReportError.log(e);\n    } else {\n        setTimeout(function() {\n            throw e;\n        });\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(function() {\n        try {\n            fn();\n        } catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    var cleanup = subscription._cleanup;\n    if (cleanup === undefined) return;\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        } else {\n            var unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    var queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for(var i = 0; i < queue.length; ++i){\n        notifySubscription(subscription, queue[i].type, queue[i].value);\n        if (subscription._state === \"closed\") break;\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    var observer = subscription._observer;\n    try {\n        var m = getMethod(observer, type);\n        switch(type){\n            case \"next\":\n                if (m) m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m) m.call(observer, value);\n                else throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m) m.call(observer);\n                break;\n        }\n    } catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") cleanupSubscription(subscription);\n    else if (subscription._state === \"running\") subscription._state = \"ready\";\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") return;\n    if (subscription._state === \"buffering\") {\n        subscription._queue.push({\n            type: type,\n            value: value\n        });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [\n            {\n                type: type,\n                value: value\n            }\n        ];\n        enqueue(function() {\n            return flushSubscription(subscription);\n        });\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nvar Subscription = /*#__PURE__*/ function() {\n    function Subscription(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        var subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        } catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") this._state = \"ready\";\n    }\n    var _proto = Subscription.prototype;\n    _proto.unsubscribe = function unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    };\n    _createClass(Subscription, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._state === \"closed\";\n            }\n        }\n    ]);\n    return Subscription;\n}();\nvar SubscriptionObserver = /*#__PURE__*/ function() {\n    function SubscriptionObserver(subscription) {\n        this._subscription = subscription;\n    }\n    var _proto2 = SubscriptionObserver.prototype;\n    _proto2.next = function next(value) {\n        onNotify(this._subscription, \"next\", value);\n    };\n    _proto2.error = function error(value) {\n        onNotify(this._subscription, \"error\", value);\n    };\n    _proto2.complete = function complete() {\n        onNotify(this._subscription, \"complete\");\n    };\n    _createClass(SubscriptionObserver, [\n        {\n            key: \"closed\",\n            get: function() {\n                return this._subscription._state === \"closed\";\n            }\n        }\n    ]);\n    return SubscriptionObserver;\n}();\nvar Observable = /*#__PURE__*/ function() {\n    function Observable(subscriber) {\n        if (!(this instanceof Observable)) throw new TypeError(\"Observable cannot be called as a function\");\n        if (typeof subscriber !== \"function\") throw new TypeError(\"Observable initializer must be a function\");\n        this._subscriber = subscriber;\n    }\n    var _proto3 = Observable.prototype;\n    _proto3.subscribe = function subscribe(observer) {\n        if (typeof observer !== \"object\" || observer === null) {\n            observer = {\n                next: observer,\n                error: arguments[1],\n                complete: arguments[2]\n            };\n        }\n        return new Subscription(observer, this._subscriber);\n    };\n    _proto3.forEach = function forEach(fn) {\n        var _this = this;\n        return new Promise(function(resolve, reject) {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve();\n            }\n            var subscription = _this.subscribe({\n                next: function(value) {\n                    try {\n                        fn(value, done);\n                    } catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve\n            });\n        });\n    };\n    _proto3.map = function map(fn) {\n        var _this2 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this2.subscribe({\n                next: function(value) {\n                    try {\n                        value = fn(value);\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.filter = function filter(fn) {\n        var _this3 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            return _this3.subscribe({\n                next: function(value) {\n                    try {\n                        if (!fn(value)) return;\n                    } catch (e) {\n                        return observer.error(e);\n                    }\n                    observer.next(value);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.reduce = function reduce(fn) {\n        var _this4 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        var hasSeed = arguments.length > 1;\n        var hasValue = false;\n        var seed = arguments[1];\n        var acc = seed;\n        return new C(function(observer) {\n            return _this4.subscribe({\n                next: function(value) {\n                    var first = !hasValue;\n                    hasValue = true;\n                    if (!first || hasSeed) {\n                        try {\n                            acc = fn(acc, value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    } else {\n                        acc = value;\n                    }\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    if (!hasValue && !hasSeed) return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                    observer.next(acc);\n                    observer.complete();\n                }\n            });\n        });\n    };\n    _proto3.concat = function concat() {\n        var _this5 = this;\n        for(var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++){\n            sources[_key] = arguments[_key];\n        }\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscription;\n            var index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next: function(v) {\n                        observer.next(v);\n                    },\n                    error: function(e) {\n                        observer.error(e);\n                    },\n                    complete: function() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        } else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    }\n                });\n            }\n            startNext(_this5);\n            return function() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    };\n    _proto3.flatMap = function flatMap(fn) {\n        var _this6 = this;\n        if (typeof fn !== \"function\") throw new TypeError(fn + \" is not a function\");\n        var C = getSpecies(this);\n        return new C(function(observer) {\n            var subscriptions = [];\n            var outer = _this6.subscribe({\n                next: function(value) {\n                    if (fn) {\n                        try {\n                            value = fn(value);\n                        } catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    var inner = C.from(value).subscribe({\n                        next: function(value) {\n                            observer.next(value);\n                        },\n                        error: function(e) {\n                            observer.error(e);\n                        },\n                        complete: function() {\n                            var i = subscriptions.indexOf(inner);\n                            if (i >= 0) subscriptions.splice(i, 1);\n                            completeIfDone();\n                        }\n                    });\n                    subscriptions.push(inner);\n                },\n                error: function(e) {\n                    observer.error(e);\n                },\n                complete: function() {\n                    completeIfDone();\n                }\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) observer.complete();\n            }\n            return function() {\n                subscriptions.forEach(function(s) {\n                    return s.unsubscribe();\n                });\n                outer.unsubscribe();\n            };\n        });\n    };\n    _proto3[SymbolObservable] = function() {\n        return this;\n    };\n    Observable.from = function from(x) {\n        var C = typeof this === \"function\" ? this : Observable;\n        if (x == null) throw new TypeError(x + \" is not an object\");\n        var method = getMethod(x, SymbolObservable);\n        if (method) {\n            var observable = method.call(x);\n            if (Object(observable) !== observable) throw new TypeError(observable + \" is not an object\");\n            if (isObservable(observable) && observable.constructor === C) return observable;\n            return new C(function(observer) {\n                return observable.subscribe(observer);\n            });\n        }\n        if (hasSymbol(\"iterator\")) {\n            method = getMethod(x, SymbolIterator);\n            if (method) {\n                return new C(function(observer) {\n                    enqueue(function() {\n                        if (observer.closed) return;\n                        for(var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done;){\n                            var item = _step.value;\n                            observer.next(item);\n                            if (observer.closed) return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(function(observer) {\n                enqueue(function() {\n                    if (observer.closed) return;\n                    for(var i = 0; i < x.length; ++i){\n                        observer.next(x[i]);\n                        if (observer.closed) return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    };\n    Observable.of = function of() {\n        for(var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            items[_key2] = arguments[_key2];\n        }\n        var C = typeof this === \"function\" ? this : Observable;\n        return new C(function(observer) {\n            enqueue(function() {\n                if (observer.closed) return;\n                for(var i = 0; i < items.length; ++i){\n                    observer.next(items[i]);\n                    if (observer.closed) return;\n                }\n                observer.complete();\n            });\n        });\n    };\n    _createClass(Observable, null, [\n        {\n            key: SymbolSpecies,\n            get: function() {\n                return this;\n            }\n        }\n    ]);\n    return Observable;\n}();\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError: hostReportError\n        },\n        configurable: true\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3plbi1vYnNlcnZhYmxlLXRzL21vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsZ0NBQWdDQyxDQUFDLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxLQUFLLE9BQU9DLFdBQVcsZUFBZUgsQ0FBQyxDQUFDRyxPQUFPQyxRQUFRLENBQUMsSUFBSUosQ0FBQyxDQUFDLGFBQWE7SUFBRSxJQUFJRSxJQUFJLE9BQU8sQ0FBQ0EsS0FBS0EsR0FBR0csSUFBSSxDQUFDTCxFQUFDLEVBQUdNLElBQUksQ0FBQ0MsSUFBSSxDQUFDTDtJQUFLLElBQUlNLE1BQU1DLE9BQU8sQ0FBQ1QsTUFBT0UsQ0FBQUEsS0FBS1EsNEJBQTRCVixFQUFDLEtBQU1DLGtCQUFrQkQsS0FBSyxPQUFPQSxFQUFFVyxNQUFNLEtBQUssVUFBVTtRQUFFLElBQUlULElBQUlGLElBQUlFO1FBQUksSUFBSVUsSUFBSTtRQUFHLE9BQU87WUFBYyxJQUFJQSxLQUFLWixFQUFFVyxNQUFNLEVBQUUsT0FBTztnQkFBRUUsTUFBTTtZQUFLO1lBQUcsT0FBTztnQkFBRUEsTUFBTTtnQkFBT0MsT0FBT2QsQ0FBQyxDQUFDWSxJQUFJO1lBQUM7UUFBRztJQUFHO0lBQUUsTUFBTSxJQUFJRyxVQUFVO0FBQTBJO0FBRTNsQixTQUFTTCw0QkFBNEJWLENBQUMsRUFBRWdCLE1BQU07SUFBSSxJQUFJLENBQUNoQixHQUFHO0lBQVEsSUFBSSxPQUFPQSxNQUFNLFVBQVUsT0FBT2lCLGtCQUFrQmpCLEdBQUdnQjtJQUFTLElBQUlFLElBQUlDLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDaEIsSUFBSSxDQUFDTCxHQUFHc0IsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFJLElBQUlKLE1BQU0sWUFBWWxCLEVBQUV1QixXQUFXLEVBQUVMLElBQUlsQixFQUFFdUIsV0FBVyxDQUFDQyxJQUFJO0lBQUUsSUFBSU4sTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT1YsTUFBTWlC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QnhCLE9BQU9rQixjQUFjLENBQUNtQixZQUFZckQsT0FBTyxlQUFlO1FBQ3REVyxPQUFPO1lBQ0w4SCxRQUFRM0Y7WUFDUlUsaUJBQWlCQTtRQUNuQjtRQUNBeEIsY0FBYztJQUNoQjtBQUNGO0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGJ0cy1hZG1pbi8uLi8uLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUtdHMvbW9kdWxlLmpzP2JiYjgiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyByZXR1cm4gZnVuY3Rpb24gKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLy8gPT09IFN5bWJvbCBTdXBwb3J0ID09PVxudmFyIGhhc1N5bWJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nO1xufTtcblxudmFyIGhhc1N5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2xzKCkgJiYgQm9vbGVhbihTeW1ib2xbbmFtZV0pO1xufTtcblxudmFyIGdldFN5bWJvbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBoYXNTeW1ib2wobmFtZSkgPyBTeW1ib2xbbmFtZV0gOiAnQEAnICsgbmFtZTtcbn07XG5cbmlmIChoYXNTeW1ib2xzKCkgJiYgIWhhc1N5bWJvbCgnb2JzZXJ2YWJsZScpKSB7XG4gIFN5bWJvbC5vYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG59XG5cbnZhciBTeW1ib2xJdGVyYXRvciA9IGdldFN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sKCdvYnNlcnZhYmxlJyk7XG52YXIgU3ltYm9sU3BlY2llcyA9IGdldFN5bWJvbCgnc3BlY2llcycpOyAvLyA9PT0gQWJzdHJhY3QgT3BlcmF0aW9ucyA9PT1cblxuZnVuY3Rpb24gZ2V0TWV0aG9kKG9iaiwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcih2YWx1ZSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWVzKG9iaikge1xuICB2YXIgY3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcblxuICBpZiAoY3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3RvciA9IGN0b3JbU3ltYm9sU3BlY2llc107XG5cbiAgICBpZiAoY3RvciA9PT0gbnVsbCkge1xuICAgICAgY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3RvciAhPT0gdW5kZWZpbmVkID8gY3RvciA6IE9ic2VydmFibGU7XG59XG5cbmZ1bmN0aW9uIGlzT2JzZXJ2YWJsZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgT2JzZXJ2YWJsZTsgLy8gU1BFQzogQnJhbmQgY2hlY2tcbn1cblxuZnVuY3Rpb24gaG9zdFJlcG9ydEVycm9yKGUpIHtcbiAgaWYgKGhvc3RSZXBvcnRFcnJvci5sb2cpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IubG9nKGUpO1xuICB9IGVsc2Uge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlKGZuKSB7XG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBmbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fY2xlYW51cDtcbiAgaWYgKGNsZWFudXAgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICBzdWJzY3JpcHRpb24uX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFjbGVhbnVwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVuc3Vic2NyaWJlID0gZ2V0TWV0aG9kKGNsZWFudXAsICd1bnN1YnNjcmliZScpO1xuXG4gICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdW5zdWJzY3JpYmUuY2FsbChjbGVhbnVwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBob3N0UmVwb3J0RXJyb3IoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHN1YnNjcmlwdGlvbi5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAnY2xvc2VkJztcbn1cblxuZnVuY3Rpb24gZmx1c2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIHZhciBxdWV1ZSA9IHN1YnNjcmlwdGlvbi5fcXVldWU7XG5cbiAgaWYgKCFxdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN1YnNjcmlwdGlvbi5fcXVldWUgPSB1bmRlZmluZWQ7XG4gIHN1YnNjcmlwdGlvbi5fc3RhdGUgPSAncmVhZHknO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBxdWV1ZVtpXS50eXBlLCBxdWV1ZVtpXS52YWx1ZSk7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpZnlTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCB0eXBlLCB2YWx1ZSkge1xuICBzdWJzY3JpcHRpb24uX3N0YXRlID0gJ3J1bm5pbmcnO1xuICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX29ic2VydmVyO1xuXG4gIHRyeSB7XG4gICAgdmFyIG0gPSBnZXRNZXRob2Qob2JzZXJ2ZXIsIHR5cGUpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjbG9zZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBpZiAobSkgbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7ZWxzZSB0aHJvdyB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgICAgY2xvc2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgaWYgKG0pIG0uY2FsbChvYnNlcnZlcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGhvc3RSZXBvcnRFcnJvcihlKTtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlID09PSAnY2xvc2VkJykgY2xlYW51cFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO2Vsc2UgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdydW5uaW5nJykgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdyZWFkeSc7XG59XG5cbmZ1bmN0aW9uIG9uTm90aWZ5KHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnKSByZXR1cm47XG5cbiAgaWYgKHN1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdidWZmZXJpbmcnKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9xdWV1ZS5wdXNoKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdWJzY3JpcHRpb24uX3N0YXRlICE9PSAncmVhZHknKSB7XG4gICAgc3Vic2NyaXB0aW9uLl9zdGF0ZSA9ICdidWZmZXJpbmcnO1xuICAgIHN1YnNjcmlwdGlvbi5fcXVldWUgPSBbe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH1dO1xuICAgIGVucXVldWUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZsdXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbm90aWZ5U3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgdHlwZSwgdmFsdWUpO1xufVxuXG52YXIgU3Vic2NyaXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKSB7XG4gICAgLy8gQVNTRVJUOiBvYnNlcnZlciBpcyBhbiBvYmplY3RcbiAgICAvLyBBU1NFUlQ6IHN1YnNjcmliZXIgaXMgY2FsbGFibGVcbiAgICB0aGlzLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy5fcXVldWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhdGUgPSAnaW5pdGlhbGl6aW5nJztcbiAgICB2YXIgc3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSBuZXcgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIodGhpcyk7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy5fY2xlYW51cCA9IHN1YnNjcmliZXIuY2FsbCh1bmRlZmluZWQsIHN1YnNjcmlwdGlvbk9ic2VydmVyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzdWJzY3JpcHRpb25PYnNlcnZlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09ICdpbml0aWFsaXppbmcnKSB0aGlzLl9zdGF0ZSA9ICdyZWFkeSc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3Vic2NyaXB0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8udW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICBjbG9zZVN1YnNjcmlwdGlvbih0aGlzKTtcbiAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhTdWJzY3JpcHRpb24sIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSAnY2xvc2VkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG52YXIgU3Vic2NyaXB0aW9uT2JzZXJ2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb25PYnNlcnZlcihzdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IFN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLm5leHQgPSBmdW5jdGlvbiBuZXh0KHZhbHVlKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnbmV4dCcsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmVycm9yID0gZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICBvbk5vdGlmeSh0aGlzLl9zdWJzY3JpcHRpb24sICdlcnJvcicsIHZhbHVlKTtcbiAgfTtcblxuICBfcHJvdG8yLmNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgb25Ob3RpZnkodGhpcy5fc3Vic2NyaXB0aW9uLCAnY29tcGxldGUnKTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU3Vic2NyaXB0aW9uT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcImNsb3NlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbi5fc3RhdGUgPT09ICdjbG9zZWQnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb25PYnNlcnZlcjtcbn0oKTtcblxudmFyIE9ic2VydmFibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZXIpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ic2VydmFibGUgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVyICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYnNlcnZhYmxlIGluaXRpYWxpemVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIHRoaXMuX3N1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICB9XG5cbiAgdmFyIF9wcm90bzMgPSBPYnNlcnZhYmxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICBvYnNlcnZlciA9IHtcbiAgICAgICAgbmV4dDogb2JzZXJ2ZXIsXG4gICAgICAgIGVycm9yOiBhcmd1bWVudHNbMV0sXG4gICAgICAgIGNvbXBsZXRlOiBhcmd1bWVudHNbMl1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX3N1YnNjcmliZXIpO1xuICB9O1xuXG4gIF9wcm90bzMuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBfdGhpcy5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4odmFsdWUsIGRvbmUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMubWFwID0gZnVuY3Rpb24gbWFwKGZuKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZuKHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90bzMuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGZuKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKGZuICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgIHZhciBDID0gZ2V0U3BlY2llcyh0aGlzKTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICByZXR1cm4gX3RoaXMzLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWZuKHZhbHVlKSkgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5yZWR1Y2UgPSBmdW5jdGlvbiByZWR1Y2UoZm4pIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoZm4gKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIEMgPSBnZXRTcGVjaWVzKHRoaXMpO1xuICAgIHZhciBoYXNTZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGFjYyA9IHNlZWQ7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgcmV0dXJuIF90aGlzNC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgZmlyc3QgPSAhaGFzVmFsdWU7XG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFmaXJzdCB8fCBoYXNTZWVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhY2MgPSBmbihhY2MsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2MgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzVmFsdWUgJiYgIWhhc1NlZWQpIHJldHVybiBvYnNlcnZlci5lcnJvcihuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVkdWNlIGFuIGVtcHR5IHNlcXVlbmNlJykpO1xuICAgICAgICAgIG9ic2VydmVyLm5leHQoYWNjKTtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8zLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgc291cmNlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIGZ1bmN0aW9uIHN0YXJ0TmV4dChuZXh0KSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG5leHQuc3Vic2NyaWJlKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydE5leHQoQy5mcm9tKHNvdXJjZXNbaW5kZXgrK10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzdGFydE5leHQoX3RoaXM1KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvMy5mbGF0TWFwID0gZnVuY3Rpb24gZmxhdE1hcChmbikge1xuICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcihmbiArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgQyA9IGdldFNwZWNpZXModGhpcyk7XG4gICAgcmV0dXJuIG5ldyBDKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICAgICAgdmFyIG91dGVyID0gX3RoaXM2LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBmbih2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5uZXIgPSBDLmZyb20odmFsdWUpLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKGlubmVyKTtcbiAgICAgICAgICAgICAgaWYgKGkgPj0gMCkgc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGNvbXBsZXRlSWZEb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKGlubmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tcGxldGVJZkRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlSWZEb25lKCkge1xuICAgICAgICBpZiAob3V0ZXIuY2xvc2VkICYmIHN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvM1tTeW1ib2xPYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBPYnNlcnZhYmxlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHgpIHtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6IE9ic2VydmFibGU7XG4gICAgaWYgKHggPT0gbnVsbCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgdmFyIG1ldGhvZCA9IGdldE1ldGhvZCh4LCBTeW1ib2xPYnNlcnZhYmxlKTtcblxuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHZhciBvYnNlcnZhYmxlID0gbWV0aG9kLmNhbGwoeCk7XG4gICAgICBpZiAoT2JqZWN0KG9ic2VydmFibGUpICE9PSBvYnNlcnZhYmxlKSB0aHJvdyBuZXcgVHlwZUVycm9yKG9ic2VydmFibGUgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAgIGlmIChpc09ic2VydmFibGUob2JzZXJ2YWJsZSkgJiYgb2JzZXJ2YWJsZS5jb25zdHJ1Y3RvciA9PT0gQykgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaGFzU3ltYm9sKCdpdGVyYXRvcicpKSB7XG4gICAgICBtZXRob2QgPSBnZXRNZXRob2QoeCwgU3ltYm9sSXRlcmF0b3IpO1xuXG4gICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZShtZXRob2QuY2FsbCh4KSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXRlbSk7XG4gICAgICAgICAgICAgIGlmIChvYnNlcnZlci5jbG9zZWQpIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiBuZXcgQyhmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KHhbaV0pO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBub3Qgb2JzZXJ2YWJsZScpO1xuICB9O1xuXG4gIE9ic2VydmFibGUub2YgPSBmdW5jdGlvbiBvZigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicgPyB0aGlzIDogT2JzZXJ2YWJsZTtcbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICBlbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9ic2VydmVyLmNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KGl0ZW1zW2ldKTtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIuY2xvc2VkKSByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKE9ic2VydmFibGUsIG51bGwsIFt7XG4gICAga2V5OiBTeW1ib2xTcGVjaWVzLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmFibGU7XG59KCk7XG5cbmlmIChoYXNTeW1ib2xzKCkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGUsIFN5bWJvbCgnZXh0ZW5zaW9ucycpLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHN5bWJvbDogU3ltYm9sT2JzZXJ2YWJsZSxcbiAgICAgIGhvc3RSZXBvcnRFcnJvcjogaG9zdFJlcG9ydEVycm9yXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IE9ic2VydmFibGUgfTtcbiJdLCJuYW1lcyI6WyJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlIiwibyIsImFsbG93QXJyYXlMaWtlIiwiaXQiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNhbGwiLCJuZXh0IiwiYmluZCIsIkFycmF5IiwiaXNBcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsImxlbmd0aCIsImkiLCJkb25lIiwidmFsdWUiLCJUeXBlRXJyb3IiLCJtaW5MZW4iLCJfYXJyYXlMaWtlVG9BcnJheSIsIm4iLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiZnJvbSIsInRlc3QiLCJhcnIiLCJsZW4iLCJhcnIyIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiaGFzU3ltYm9scyIsImhhc1N5bWJvbCIsIkJvb2xlYW4iLCJnZXRTeW1ib2wiLCJvYnNlcnZhYmxlIiwiU3ltYm9sSXRlcmF0b3IiLCJTeW1ib2xPYnNlcnZhYmxlIiwiU3ltYm9sU3BlY2llcyIsImdldE1ldGhvZCIsIm9iaiIsInVuZGVmaW5lZCIsImdldFNwZWNpZXMiLCJjdG9yIiwiT2JzZXJ2YWJsZSIsImlzT2JzZXJ2YWJsZSIsIngiLCJob3N0UmVwb3J0RXJyb3IiLCJlIiwibG9nIiwic2V0VGltZW91dCIsImVucXVldWUiLCJmbiIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImNsZWFudXBTdWJzY3JpcHRpb24iLCJzdWJzY3JpcHRpb24iLCJjbGVhbnVwIiwiX2NsZWFudXAiLCJ1bnN1YnNjcmliZSIsImNsb3NlU3Vic2NyaXB0aW9uIiwiX29ic2VydmVyIiwiX3F1ZXVlIiwiX3N0YXRlIiwiZmx1c2hTdWJzY3JpcHRpb24iLCJxdWV1ZSIsIm5vdGlmeVN1YnNjcmlwdGlvbiIsInR5cGUiLCJvYnNlcnZlciIsIm0iLCJvbk5vdGlmeSIsInB1c2giLCJTdWJzY3JpcHRpb24iLCJzdWJzY3JpYmVyIiwic3Vic2NyaXB0aW9uT2JzZXJ2ZXIiLCJTdWJzY3JpcHRpb25PYnNlcnZlciIsImVycm9yIiwiX3Byb3RvIiwiZ2V0IiwiX3N1YnNjcmlwdGlvbiIsIl9wcm90bzIiLCJjb21wbGV0ZSIsIl9zdWJzY3JpYmVyIiwiX3Byb3RvMyIsInN1YnNjcmliZSIsImFyZ3VtZW50cyIsImZvckVhY2giLCJfdGhpcyIsInJlamVjdCIsIm1hcCIsIl90aGlzMiIsIkMiLCJmaWx0ZXIiLCJfdGhpczMiLCJyZWR1Y2UiLCJfdGhpczQiLCJoYXNTZWVkIiwiaGFzVmFsdWUiLCJzZWVkIiwiYWNjIiwiZmlyc3QiLCJjb25jYXQiLCJfdGhpczUiLCJfbGVuIiwic291cmNlcyIsIl9rZXkiLCJpbmRleCIsInN0YXJ0TmV4dCIsInYiLCJmbGF0TWFwIiwiX3RoaXM2Iiwic3Vic2NyaXB0aW9ucyIsIm91dGVyIiwiaW5uZXIiLCJpbmRleE9mIiwic3BsaWNlIiwiY29tcGxldGVJZkRvbmUiLCJjbG9zZWQiLCJzIiwibWV0aG9kIiwiX2l0ZXJhdG9yIiwiX3N0ZXAiLCJpdGVtIiwib2YiLCJfbGVuMiIsIml0ZW1zIiwiX2tleTIiLCJzeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/zen-observable-ts/module.js\n");

/***/ })

};
;